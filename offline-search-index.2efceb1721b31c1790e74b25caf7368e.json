[{"body":" tour/create_statements/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string } var ( schema = ` CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL ) ` // Single column queries do not need mapping definition. // Params are always parameterized preventing SQL injection. // Placeholders can be defined with sqlt.Option's (default: Question). insertBook = sqlt.First[string, int64](sqlt.Question, sqlt.Parse(` INSERT INTO books (title) VALUES ({{ . }}) RETURNING id; `)) // Define the mapping with Scan functions. // Scan can be used with any scannable type. // One ensures that only one row is returned by the query (else: sqlt.ErrTooManyRows). getBook = sqlt.One[int64, Book](sqlt.Parse(` SELECT id {{ Scan \"ID\" }} , title {{ Scan \"Title\" }} FROM books WHERE id = {{ . }}; `)) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = db.Exec(schema) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, title string) (int64, error) { return insertBook.Exec(ctx, r.DB, title) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 2. Load from file ","categories":"","description":"This simple example demonstrates how to execute SQL statements and map the results to Go structs using sqlt.\n","excerpt":"This simple example demonstrates how to execute SQL statements and map …","ref":"/tour/1_create_statements/","tags":"","title":"1. Create statements"},{"body":" tour/load_from_file/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL ); {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title) VALUES ({{ . }}) RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT id {{ Scan \"ID\" }} , title {{ Scan \"Title\" }} FROM books WHERE id = {{ . }}; {{ end }} tour/load_from_file/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string } var ( config = sqlt.Config{ Templates: []sqlt.Template{ sqlt.ParseFiles(\"load_from_file/queries.go.tpl\"), }, } // sqlt.Config and Lookup implement the sqlt.Option interface. schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) // Statements panic if a template error occurs or a type-safety check fails. // Therefore, they should be created at application startup. insertBook = sqlt.First[string, int64](config, sqlt.Lookup(\"insert_book\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, title string) (int64, error) { return insertBook.Exec(ctx, r.DB, title) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 3. Bulk insert ","categories":"","description":"Learn how to load SQL from a file and execute type-safe statements using sqlt.\n","excerpt":"Learn how to load SQL from a file and execute type-safe statements …","ref":"/tour/2_load_from_file/","tags":"","title":"2. Load from file"},{"body":" tour/bulk_insert/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, author TEXT NOT NULL ) {{ end }} {{/* sqlt uses github.com/jba/templatecheck to check input parameters. */}} {{ define \"insert_book\" }} INSERT INTO books (title, author) VALUES ({{ .Title }}, {{ .Author }}) RETURNING id; {{ end }} {{/* You can use range/if to create dynamic queries. */}} {{ define \"insert_books\" }} INSERT INTO books (title, author) VALUES {{ range $i, $c := . }} {{ if $i }}, {{ end }} ({{ $c.Title }}, {{ $c.Author }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT id {{ Scan \"ID\" }} , title {{ Scan \"Title\" }} , author {{ Scan \"Author\" }} FROM books WHERE id = {{ . }}; {{ end }} tour/bulk_insert/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Author string } type Params struct { Title string Author string } var ( config = sqlt.Config{ Templates: []sqlt.Template{ sqlt.ParseFiles(\"bulk_insert/queries.go.tpl\"), }, } schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) insertBook = sqlt.First[Params, int64](config, sqlt.Lookup(\"insert_book\")) insertBooks = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Params) (int64, error) { return insertBook.Exec(ctx, r.DB, params) } func (r Repository) CreateMany(ctx context.Context, params []Params) ([]int64, error) { return insertBooks.Exec(ctx, r.DB, params) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 4. Transactions ","categories":"","description":"This example shows how to create statements for bulk inserts.\n","excerpt":"This example shows how to create statements for bulk inserts.\n","ref":"/tour/3_bulk_insert/","tags":"","title":"3. Bulk insert"},{"body":" tour/transactions/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, author_id INTEGER REFERENCES authors(id), added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); {{ end }} {{ define \"upsert_author\" }} INSERT INTO authors (name) VALUES ({{ . }}) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{/* \"now\" is a template function imported from Masterminds/sprig. */}} {{ define \"insert_book\" }} INSERT INTO books (title, author_id, added_at) VALUES ({{ .Title }}, {{ .AuthorID }}, {{ now }}) RETURNING id; {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Author }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_books\" }} {{ $now := now }} INSERT INTO books (title, author_id, added_at) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Title }}, {{ $p.AuthorID }}, {{ $now }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT books.id {{ Scan \"ID\" }} , books.title {{ Scan \"Title\" }} , authors.name {{ Scan \"Author\" }} , books.added_at {{ Scan \"AddedAt\" }} FROM books LEFT JOIN authors ON authors.id = books.author_id WHERE books.id = {{ . }}; {{ end }} tour/transactions/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Author string AddedAt time.Time } type Params struct { Title string Author string } type Insert struct { Title string AuthorID int64 } var ( config = sqlt.Config{ Templates: []sqlt.Template{ sqlt.Funcs(sprig.TxtFuncMap()), sqlt.ParseFiles(\"transactions/queries.go.tpl\"), }, } schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthor = sqlt.One[string, int64](config, sqlt.Lookup(\"upsert_author\")) insertBook = sqlt.One[Insert, int64](config, sqlt.Lookup(\"insert_book\")) upsertAuthors = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBooks = sqlt.All[[]Insert, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Params) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() author, err := upsertAuthor.Exec(ctx, tx, params.Author) if err != nil { return 0, err } return insertBook.Exec(ctx, tx, Insert{ Title: params.Title, AuthorID: author, }) } func (r Repository) CreateMany(ctx context.Context, params []Params) ([]int64, error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return nil, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authors, err := upsertAuthors.Exec(ctx, tx, params) if err != nil { return nil, err } insert := make([]Insert, len(authors)) for i, p := range authors { insert[i] = Insert{ Title: params[i].Title, AuthorID: p, } } return insertBooks.Exec(ctx, tx, insert) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 5. Custom Functions ","categories":"","description":"This example shows how to use statements in transactions.\n","excerpt":"This example shows how to use statements in transactions.\n","ref":"/tour/4_transactions/","tags":"","title":"4. Transactions"},{"body":" An alternative to this approach is to implement the sql.Scanner and sql.Valuer interfaces.\ntour/custom_functions/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, genre TEXT NOT NULL, author_id INTEGER REFERENCES authors(id), added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); {{ end }} {{ define \"upsert_author\" }} INSERT INTO authors (name) VALUES ({{ . }}) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{/* \"now\" is a template function imported from Masterminds/sprig. */}} {{ define \"insert_book\" }} INSERT INTO books (title, genre, author_id, added_at) VALUES ({{ .Title }}, {{ ValueGenre .Genre }}, {{ .AuthorID }}, {{ now }}) RETURNING id; {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Author }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_books\" }} {{ $now := now }} INSERT INTO books (title, genre, author_id, added_at) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Title }}, {{ ValueGenre $p.Genre }}, {{ $p.AuthorID }}, {{ $now }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT books.id {{ Scan \"ID\" }} , books.title {{ Scan \"Title\" }} , books.genre {{ ScanGenre }} , authors.name {{ Scan \"Author\" }} , books.added_at {{ Scan \"AddedAt\" }} FROM books LEFT JOIN authors ON authors.id = books.author_id WHERE books.id = {{ . }}; {{ end }} tour/custom_functions/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"fmt\" \"text/template\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Genre int const ( Adventure Genre = iota + 1 Tragedy Allegorical ) type Book struct { ID int64 Title string Genre Genre Author string AddedAt time.Time } type Params struct { Title string Genre Genre Author string } type Insert struct { Title string Genre Genre AuthorID int64 } var ( config = sqlt.Config{ Templates: []sqlt.Template{ sqlt.Funcs(sprig.TxtFuncMap()), sqlt.Funcs(template.FuncMap{ \"ValueGenre\": func(g Genre) (string, error) { switch g { case Adventure: return \"Adventure\", nil case Tragedy: return \"Tragedy\", nil case Allegorical: return \"Allegorical\", nil default: return \"\", fmt.Errorf(\"unknown genre: %d\", g) } }, \"ScanGenre\": func() sqlt.Scanner[Book] { return func() (any, func(dest *Book) error) { var txt string return \u0026txt, func(dest *Book) error { switch txt { case \"Adventure\": dest.Genre = Adventure case \"Tragedy\": dest.Genre = Tragedy case \"Allegorical\": dest.Genre = Allegorical default: return fmt.Errorf(\"unknown genre: %s\", txt) } return nil } } }, }), sqlt.ParseFiles(\"custom_functions/queries.go.tpl\"), }, } schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthor = sqlt.One[string, int64](config, sqlt.Lookup(\"upsert_author\")) insertBook = sqlt.One[Insert, int64](config, sqlt.Lookup(\"insert_book\")) upsertAuthors = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBooks = sqlt.All[[]Insert, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Params) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() author, err := upsertAuthor.Exec(ctx, tx, params.Author) if err != nil { return 0, err } return insertBook.Exec(ctx, tx, Insert{ Title: params.Title, Genre: params.Genre, AuthorID: author, }) } func (r Repository) CreateMany(ctx context.Context, params []Params) ([]int64, error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return nil, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authors, err := upsertAuthors.Exec(ctx, tx, params) if err != nil { return nil, err } insert := make([]Insert, len(authors)) for i, p := range authors { insert[i] = Insert{ Title: params[i].Title, Genre: params[i].Genre, AuthorID: p, } } return insertBooks.Exec(ctx, tx, insert) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 6. Complex Query ","categories":"","description":"How to use a custom Scanner.\n","excerpt":"How to use a custom Scanner.\n","ref":"/tour/5_custom_functions/","tags":"","title":"5. Custom Functions"},{"body":" tour/complex_query/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS book_authors ( book_id INTEGER REFERENCES books(id), author_id INTEGER REFERENCES authors(id), PRIMARY KEY (book_id, author_id) ); {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $a := . }} {{ if $i }}, {{ end }} ({{ $a }}) {{ end }} ON CONFLICT (name) DO UPDATE SET id = authors.id, name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title, added_at) VALUES ({{ . }}, {{ now }}) RETURNING id; {{ end }} {{ define \"link_book_authors\" }} INSERT INTO book_authors (book_id, author_id) VALUES {{ range $i, $a := .AuthorIDs }} {{ if $i }}, {{ end }} ({{ $.BookID }}, {{ $a }}) {{ end }} ON CONFLICT DO NOTHING; {{ end }} {{ define \"query_books\" }} SELECT books.id {{ Scan \"ID\" }} , books.title {{ Scan \"Title\" }} {{/* ScanStringSlice scans the column as a string and splits it into a slice of strings */}} , GROUP_CONCAT(authors.name) {{ ScanStringSlice \"Authors\" \",\" }} , books.added_at {{ Scan \"AddedAt\" }} FROM books LEFT JOIN book_authors ON books.id = book_authors.book_id LEFT JOIN authors ON authors.id = book_authors.author_id WHERE 1=1 {{ with .Title }} AND books.title = {{ . }} {{ end }} {{ with .Author }} AND books.id IN ( SELECT ba.book_id FROM book_authors ba JOIN authors a ON a.id = ba.author_id WHERE a.name = {{ . }} ) {{ end }} {{ if not .AddedBefore.IsZero }} AND books.added_at \u003c {{ .AddedBefore }} {{ end }} GROUP BY books.id, books.title, books.added_at; {{ end }} tour/complex_query/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"fmt\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Authors []string AddedAt time.Time } type Query struct { Title string Author string AddedBefore time.Time } type Insert struct { Title string Authors []string } type Link struct { BookID int64 AuthorIDs []int64 } var ( config = sqlt.Config{ Templates: []sqlt.Template{ sqlt.Funcs(sprig.TxtFuncMap()), sqlt.ParseFiles(\"complex_query/queries.go.tpl\"), }, Log: func(ctx context.Context, info sqlt.Info) { if info.Cached { fmt.Println(info.SQL, info.Args) } }, } schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthors = sqlt.All[[]string, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBook = sqlt.One[string, int64](config, sqlt.Lookup(\"insert_book\")) linkBookAuthors = sqlt.Exec[Link](config, sqlt.Lookup(\"link_book_authors\")) queryBooks = sqlt.All[Query, Book](config, sqlt.NoExpirationCache(512), sqlt.Lookup(\"query_books\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Insert) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authorIDs, err := upsertAuthors.Exec(ctx, tx, params.Authors) if err != nil { return 0, err } id, err = insertBook.Exec(ctx, tx, params.Title) if err != nil { return 0, err } _, err = linkBookAuthors.Exec(ctx, tx, Link{ BookID: id, AuthorIDs: authorIDs, }) return id, err } func (r Repository) Query(ctx context.Context, params Query) ([]Book, error) { return queryBooks.Exec(ctx, r.DB, params) } \u003e\u003e 7. Multiple Databases ","categories":"","description":"This example shows how to build complex queries.\n","excerpt":"This example shows how to build complex queries.\n","ref":"/tour/6_complex_query/","tags":"","title":"6. Complex Query"},{"body":" tour/multiple_databases/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( {{ if eq Dialect \"postgres\" }} id SERIAL PRIMARY KEY {{ else if eq Dialect \"sqlite\" }} id INTEGER PRIMARY KEY {{ else }} {{ fail \"invalid dialect\" }} {{ end }} , title TEXT NOT NULL {{ if eq Dialect \"postgres\" }} , added_at TIMESTAMPTZ NOT NULL {{ else if eq Dialect \"sqlite\" }} , added_at DATE NOT NULL {{ else }} {{ fail \"invalid dialect\" }} {{ end }} ); CREATE TABLE IF NOT EXISTS authors ( {{ if eq Dialect \"postgres\" }} id SERIAL PRIMARY KEY, {{ else if eq Dialect \"sqlite\" }} id INTEGER PRIMARY KEY, {{ else }} {{ fail \"invalid dialect\" }} {{ end }} name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS book_authors ( book_id INTEGER REFERENCES books(id), author_id INTEGER REFERENCES authors(id), PRIMARY KEY (book_id, author_id) ); {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $a := . }} {{ if $i }}, {{ end }} ({{ $a }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title, added_at) VALUES ({{ . }}, {{ now }}) RETURNING id; {{ end }} {{ define \"link_book_authors\" }} INSERT INTO book_authors (book_id, author_id) VALUES {{ range $i, $a := .AuthorIDs }} {{ if $i }}, {{ end }} ({{ $.BookID }}, {{ $a }}) {{ end }} ON CONFLICT DO NOTHING; {{ end }} {{ define \"query_books\" }} SELECT books.id {{ Scan \"ID\" }} , books.title {{ Scan \"Title\" }} {{/* ScanStringSlice scans the column as a string and splits it into a slice of strings */}} {{ if eq Dialect \"postgres\" }} , STRING_AGG(authors.name, ',') {{ ScanStringSlice \"Authors\" \",\" }} {{ else if eq Dialect \"sqlite\" }} , GROUP_CONCAT(authors.name) {{ ScanStringSlice \"Authors\" \",\" }} {{ else }} {{ fail \"invalid dialect\" }} {{ end }} , books.added_at {{ Scan \"AddedAt\" }} FROM books LEFT JOIN book_authors ON books.id = book_authors.book_id LEFT JOIN authors ON authors.id = book_authors.author_id WHERE 1=1 {{ with .Title }} AND books.title = {{ . }} {{ end }} {{ with .Author }} AND books.id IN ( SELECT ba.book_id FROM book_authors ba JOIN authors a ON a.id = ba.author_id WHERE {{ if eq Dialect \"postgres\" }} POSITION({{ . }} IN a.name) \u003e 0 {{ else if eq Dialect \"sqlite\" }} INSTR(a.name, {{ . }}) {{ else }} {{ fail \"invalid dialect\" }} {{ end }} ) {{ end }} {{ if not .AddedBefore.IsZero }} AND books.added_at \u003c {{ .AddedBefore }} {{ end }} GROUP BY books.id, books.title, books.added_at; {{ end }} tour/multiple_databases/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"text/template\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"github.com/jackc/pgx/v5/stdlib\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Authors []string AddedAt time.Time } type Query struct { Title string Author string AddedBefore time.Time } type Insert struct { Title string Authors []string } type Link struct { BookID int64 AuthorIDs []int64 } func NewRepository(db *sql.DB, opts ...sqlt.Option) (Repository, error) { config := sqlt.Configure(append(opts, sqlt.Funcs(sprig.TxtFuncMap()), sqlt.ParseFiles(\"multiple_databases/queries.go.tpl\"), )...) schema := sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) _, err := schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, Schema: sqlt.Exec[any](config, sqlt.Lookup(\"schema\")), UpsertAuthors: sqlt.All[[]string, int64](config, sqlt.Lookup(\"upsert_authors\")), InsertBook: sqlt.One[string, int64](config, sqlt.Lookup(\"insert_book\")), LinkBookAuthors: sqlt.Exec[Link](config, sqlt.Lookup(\"link_book_authors\")), QueryBooks: sqlt.All[Query, Book](config, sqlt.NoExpirationCache(512), sqlt.Lookup(\"query_books\")), }, nil } func NewSqlite() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } return NewRepository(db, sqlt.Funcs(template.FuncMap{ \"Dialect\": func() string { return \"sqlite\" }, })) } func NewPostgres(conn string) (Repository, error) { db, err := sql.Open(\"pgx\", conn) if err != nil { return Repository{}, err } return NewRepository(db, sqlt.Dollar, sqlt.Funcs(template.FuncMap{ \"Dialect\": func() string { return \"postgres\" }, })) } type Repository struct { DB *sql.DB Schema sqlt.Statement[any, sql.Result] UpsertAuthors sqlt.Statement[[]string, []int64] InsertBook sqlt.Statement[string, int64] LinkBookAuthors sqlt.Statement[Link, sql.Result] QueryBooks sqlt.Statement[Query, []Book] } func (r Repository) Create(ctx context.Context, params Insert) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authorIDs, err := r.UpsertAuthors.Exec(ctx, tx, params.Authors) if err != nil { return 0, err } id, err = r.InsertBook.Exec(ctx, tx, params.Title) if err != nil { return 0, err } _, err = r.LinkBookAuthors.Exec(ctx, tx, Link{ BookID: id, AuthorIDs: authorIDs, }) return id, err } func (r Repository) Query(ctx context.Context, params Query) ([]Book, error) { return r.QueryBooks.Exec(ctx, r.DB, params) } ","categories":"","description":"This example shows how to use sqlt with multiple databases.\n","excerpt":"This example shows how to use sqlt with multiple databases.\n","ref":"/tour/7_multiple_databases/","tags":"","title":"7. Multiple Databases"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/all/","tags":"","title":"All"},{"body":"NsPerOp AllocsPerOp AllocedBytesPerOp ","categories":"","description":"Results of the [Bench-Flix](https://github.com/go-sqlt/bench-flix) benchmarks.\n","excerpt":"Results of the [Bench-Flix](https://github.com/go-sqlt/bench-flix) …","ref":"/benchmarks/","tags":"","title":"Benchmarks"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/","tags":"","title":"Configs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/configure/","tags":"","title":"Configure"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/custom/","tags":"","title":"Custom"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/","tags":"","title":"Drivers"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/exec/","tags":"","title":"Exec"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/","tags":"","title":"Executors"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/first/","tags":"","title":"First"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/funcs/","tags":"","title":"Funcs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/jackc/pgx/","tags":"","title":"Jackc/Pgx"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/log/","tags":"","title":"Log"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/lookup/","tags":"","title":"Lookup"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/masterminds/sprig/","tags":"","title":"Masterminds/Sprig"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/modernc.org/sqlite/","tags":"","title":"Modernc.org/Sqlite"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/noexpirationcache/","tags":"","title":"NoExpirationCache"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/one/","tags":"","title":"One"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/parse/","tags":"","title":"Parse"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/parsefiles/","tags":"","title":"ParseFiles"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/question/","tags":"","title":"Question"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scan/","tags":"","title":"Scan"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/","tags":"","title":"Scanners"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanstringslice/","tags":"","title":"ScanStringSlice"}]