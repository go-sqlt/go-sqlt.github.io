[{"body":" tour/create_statements/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string } var ( schema = ` CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL ); ` // Question is the default placeholder. config = sqlt.Question() // Single column queries do not need mapping definition. // Params are always parameterized preventing SQL injection. insertBook = sqlt.First[string, int64](config, sqlt.Parse(` INSERT INTO books (title) VALUES ({{ . }}) RETURNING id; `)) // Define the mapping with Scan functions. // One ensures that only one row is returned by the query (else: sqlt.ErrTooManyRows). getBook = sqlt.One[int64, Book](config, sqlt.Parse(` SELECT id {{ ScanInt \"ID\" }} , title {{ ScanString \"Title\" }} FROM books WHERE id = {{ . }}; `)) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = db.Exec(schema) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, title string) (int64, error) { return insertBook.Exec(ctx, r.DB, title) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 2. Load from file ","categories":"","description":"This simple example demonstrates how to execute SQL statements and map the results to Go structs using sqlt.\n","excerpt":"This simple example demonstrates how to execute SQL statements and map …","ref":"/tour/1_create_statements/","tags":"","title":"1. Create statements"},{"body":" tour/load_from_file/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL ); {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title) VALUES ({{ . }}) RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT id {{ ScanInt \"ID\" }} , title {{ ScanString \"Title\" }} FROM books WHERE id = {{ . }}; {{ end }} tour/load_from_file/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string } var ( config = sqlt.ParseFiles(\"load_from_file/queries.go.tpl\") // sqlt.Config and Lookup implement the sqlt.Option interface. schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) // Statements panic if a template error occurs or a type-safety check fails. // Therefore, they should be created at application startup. insertBook = sqlt.First[string, int64](config, sqlt.Lookup(\"insert_book\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, title string) (int64, error) { return insertBook.Exec(ctx, r.DB, title) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 3. Bulk insert ","categories":"","description":"Learn how to load SQL from a file and execute type-safe statements using sqlt.\n","excerpt":"Learn how to load SQL from a file and execute type-safe statements …","ref":"/tour/2_load_from_file/","tags":"","title":"2. Load from file"},{"body":" tour/bulk_insert/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, author TEXT NOT NULL ) {{ end }} {{/* sqlt uses github.com/jba/templatecheck to check input parameters. */}} {{ define \"insert_book\" }} INSERT INTO books (title, author) VALUES ({{ .Title }}, {{ .Author }}) RETURNING id; {{ end }} {{/* You can use range/if to create dynamic queries. */}} {{ define \"insert_books\" }} INSERT INTO books (title, author) VALUES {{ range $i, $c := . }} {{ if $i }}, {{ end }} ({{ $c.Title }}, {{ $c.Author }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT id {{ ScanInt \"ID\" }} , title {{ ScanString \"Title\" }} , author {{ ScanString \"Author\" }} FROM books WHERE id = {{ . }}; {{ end }} tour/bulk_insert/repository.go package repository import ( \"context\" \"database/sql\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Author string } type Params struct { Title string Author string } var ( config = sqlt.ParseFiles(\"bulk_insert/queries.go.tpl\") schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) insertBook = sqlt.First[Params, int64](config, sqlt.Lookup(\"insert_book\")) insertBooks = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Params) (int64, error) { return insertBook.Exec(ctx, r.DB, params) } func (r Repository) CreateMany(ctx context.Context, params []Params) ([]int64, error) { return insertBooks.Exec(ctx, r.DB, params) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 4. Transactions ","categories":"","description":"This example shows how to create statements for bulk inserts.\n","excerpt":"This example shows how to create statements for bulk inserts.\n","ref":"/tour/3_bulk_insert/","tags":"","title":"3. Bulk insert"},{"body":" tour/transactions/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, author_id INTEGER REFERENCES authors(id), added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); {{ end }} {{ define \"upsert_author\" }} INSERT INTO authors (name) VALUES ({{ . }}) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{/* \"now\" is a template function imported from Masterminds/sprig. */}} {{ define \"insert_book\" }} INSERT INTO books (title, author_id, added_at) VALUES ({{ .Title }}, {{ .AuthorID }}, {{ now }}) RETURNING id; {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Author }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_books\" }} {{ $now := now }} INSERT INTO books (title, author_id, added_at) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Title }}, {{ $p.AuthorID }}, {{ $now }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT books.id {{ ScanInt \"ID\" }} , books.title {{ ScanString \"Title\" }} , authors.name {{ ScanString \"Author\" }} , books.added_at {{ ScanTime \"AddedAt\" }} FROM books LEFT JOIN authors ON authors.id = books.author_id WHERE books.id = {{ . }}; {{ end }} tour/transactions/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Author string AddedAt time.Time } type Params struct { Title string Author string } type Insert struct { Title string AuthorID int64 } var ( config = sqlt.Funcs(sprig.TxtFuncMap()).With( sqlt.ParseFiles(\"transactions/queries.go.tpl\"), ) schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthor = sqlt.One[string, int64](config, sqlt.Lookup(\"upsert_author\")) insertBook = sqlt.One[Insert, int64](config, sqlt.Lookup(\"insert_book\")) upsertAuthors = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBooks = sqlt.All[[]Insert, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } // Transactions should not be abstracted away by a SQL framework. // This is an example of using them with the Repository pattern. // In real-world applications, managing transactions is usually // more appropriate in the business/service layer. func (r Repository) Create(ctx context.Context, params Params) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() author, err := upsertAuthor.Exec(ctx, tx, params.Author) if err != nil { return 0, err } return insertBook.Exec(ctx, tx, Insert{ Title: params.Title, AuthorID: author, }) } func (r Repository) CreateMany(ctx context.Context, params []Params) (ids []int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return nil, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authors, err := upsertAuthors.Exec(ctx, tx, params) if err != nil { return nil, err } insert := make([]Insert, len(authors)) for i, p := range authors { insert[i] = Insert{ Title: params[i].Title, AuthorID: p, } } return insertBooks.Exec(ctx, tx, insert) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 5. Custom Functions ","categories":"","description":"This example shows how to use statements in transactions.\n","excerpt":"This example shows how to use statements in transactions.\n","ref":"/tour/4_transactions/","tags":"","title":"4. Transactions"},{"body":" An alternative to this approach is to implement the sql.Scanner and sql.Valuer interfaces.\ntour/custom_functions/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, genre TEXT NOT NULL, author_id INTEGER REFERENCES authors(id), added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); {{ end }} {{ define \"upsert_author\" }} INSERT INTO authors (name) VALUES ({{ . }}) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{/* \"now\" is a template function imported from Masterminds/sprig. */}} {{ define \"insert_book\" }} INSERT INTO books (title, genre, author_id, added_at) VALUES ({{ .Title }}, {{ ValueGenre .Genre }}, {{ .AuthorID }}, {{ now }}) RETURNING id; {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Author }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_books\" }} {{ $now := now }} INSERT INTO books (title, genre, author_id, added_at) VALUES {{ range $i, $p := . }} {{ if $i }}, {{ end }} ({{ $p.Title }}, {{ ValueGenre $p.Genre }}, {{ $p.AuthorID }}, {{ $now }}) {{ end }} RETURNING id; {{ end }} {{ define \"get_book\" }} SELECT books.id {{ ScanInt \"ID\" }} , books.title {{ ScanString \"Title\" }} , books.genre {{ ScanGenre }} , authors.name {{ ScanString \"Author\" }} , books.added_at {{ ScanTime \"AddedAt\" }} FROM books LEFT JOIN authors ON authors.id = books.author_id WHERE books.id = {{ . }}; {{ end }} tour/custom_functions/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"fmt\" \"text/template\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Genre int const ( Adventure Genre = iota + 1 Tragedy Allegorical ) type Book struct { ID int64 Title string Genre Genre Author string AddedAt time.Time } type Params struct { Title string Genre Genre Author string } type Insert struct { Title string Genre Genre AuthorID int64 } var ( config = sqlt.Funcs(sprig.TxtFuncMap()).With( sqlt.Funcs(template.FuncMap{ \"ValueGenre\": func(g Genre) (string, error) { switch g { case Adventure: return \"Adventure\", nil case Tragedy: return \"Tragedy\", nil case Allegorical: return \"Allegorical\", nil default: return \"\", fmt.Errorf(\"unknown genre: %d\", g) } }, \"ScanGenre\": func() sqlt.Scanner[Book] { return func() (any, func(dest *Book) error) { var txt string return \u0026txt, func(dest *Book) error { switch txt { case \"Adventure\": dest.Genre = Adventure case \"Tragedy\": dest.Genre = Tragedy case \"Allegorical\": dest.Genre = Allegorical default: return fmt.Errorf(\"unknown genre: %s\", txt) } return nil } } }, }), sqlt.ParseFiles(\"custom_functions/queries.go.tpl\"), ) schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthor = sqlt.One[string, int64](config, sqlt.Lookup(\"upsert_author\")) insertBook = sqlt.One[Insert, int64](config, sqlt.Lookup(\"insert_book\")) upsertAuthors = sqlt.All[[]Params, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBooks = sqlt.All[[]Insert, int64](config, sqlt.Lookup(\"insert_books\")) getBook = sqlt.First[int64, Book](config, sqlt.Lookup(\"get_book\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Params) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() author, err := upsertAuthor.Exec(ctx, tx, params.Author) if err != nil { return 0, err } return insertBook.Exec(ctx, tx, Insert{ Title: params.Title, Genre: params.Genre, AuthorID: author, }) } func (r Repository) CreateMany(ctx context.Context, params []Params) (ids []int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return nil, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authors, err := upsertAuthors.Exec(ctx, tx, params) if err != nil { return nil, err } insert := make([]Insert, len(authors)) for i, p := range authors { insert[i] = Insert{ Title: params[i].Title, Genre: params[i].Genre, AuthorID: p, } } return insertBooks.Exec(ctx, tx, insert) } func (r Repository) Get(ctx context.Context, id int64) (Book, error) { return getBook.Exec(ctx, r.DB, id) } \u003e\u003e 6. Complex Query ","categories":"","description":"How to use a custom Scanner.\n","excerpt":"How to use a custom Scanner.\n","ref":"/tour/5_custom_functions/","tags":"","title":"5. Custom Functions"},{"body":" tour/complex_query/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY, title TEXT NOT NULL, added_at DATE NOT NULL ); CREATE TABLE IF NOT EXISTS authors ( id INTEGER PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS book_authors ( book_id INTEGER REFERENCES books(id), author_id INTEGER REFERENCES authors(id), PRIMARY KEY (book_id, author_id) ); {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $a := . }} {{ if $i }}, {{ end }} ({{ $a }}) {{ end }} ON CONFLICT (name) DO UPDATE SET id = authors.id, name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title, added_at) VALUES ({{ . }}, {{ now }}) RETURNING id; {{ end }} {{ define \"link_book_authors\" }} INSERT INTO book_authors (book_id, author_id) VALUES {{ range $i, $a := .AuthorIDs }} {{ if $i }}, {{ end }} ({{ $.BookID }}, {{ $a }}) {{ end }} ON CONFLICT DO NOTHING; {{ end }} {{ define \"query_books\" }} SELECT books.id {{ ScanInt \"ID\" }} , books.title {{ ScanString \"Title\" }} {{/* ScanStringSlice scans the column as a string and splits it into a slice of strings */}} , GROUP_CONCAT(authors.name) {{ ScanStringSlice \"Authors\" \",\" }} , books.added_at {{ ScanTime \"AddedAt\" }} FROM books LEFT JOIN book_authors ON books.id = book_authors.book_id LEFT JOIN authors ON authors.id = book_authors.author_id WHERE 1=1 {{ with .Title }} AND books.title = {{ . }} {{ end }} {{ with .Author }} AND books.id IN ( SELECT ba.book_id FROM book_authors ba JOIN authors a ON a.id = ba.author_id WHERE a.name = {{ . }} ) {{ end }} {{ if not .AddedBefore.IsZero }} AND books.added_at \u003c {{ .AddedBefore }} {{ end }} GROUP BY books.id, books.title, books.added_at; {{ end }} tour/complex_query/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"fmt\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Authors []string AddedAt time.Time } type Query struct { Title string Author string AddedBefore time.Time } type Insert struct { Title string Authors []string } type Link struct { BookID int64 AuthorIDs []int64 } var ( config = sqlt.Funcs(sprig.TxtFuncMap()).With( sqlt.ParseFiles(\"complex_query/queries.go.tpl\"), sqlt.Log(func(ctx context.Context, info sqlt.Info) { if info.Cached { fmt.Println(info.SQL, info.Args) } }), ) schema = sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) upsertAuthors = sqlt.All[[]string, int64](config, sqlt.Lookup(\"upsert_authors\")) insertBook = sqlt.One[string, int64](config, sqlt.Lookup(\"insert_book\")) linkBookAuthors = sqlt.Exec[Link](config, sqlt.Lookup(\"link_book_authors\")) queryBooks = sqlt.All[Query, Book](config, sqlt.NoExpirationCache(512), sqlt.Lookup(\"query_books\")) ) func NewRepository() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } _, err = schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, }, nil } type Repository struct { DB *sql.DB } func (r Repository) Create(ctx context.Context, params Insert) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authorIDs, err := upsertAuthors.Exec(ctx, tx, params.Authors) if err != nil { return 0, err } id, err = insertBook.Exec(ctx, tx, params.Title) if err != nil { return 0, err } _, err = linkBookAuthors.Exec(ctx, tx, Link{ BookID: id, AuthorIDs: authorIDs, }) return id, err } func (r Repository) Query(ctx context.Context, params Query) ([]Book, error) { return queryBooks.Exec(ctx, r.DB, params) } \u003e\u003e 7. Multiple Databases ","categories":"","description":"This example shows how to build complex queries.\n","excerpt":"This example shows how to build complex queries.\n","ref":"/tour/6_complex_query/","tags":"","title":"6. Complex Query"},{"body":" tour/multiple_databases/queries.go.tpl {{ define \"schema\" }} CREATE TABLE IF NOT EXISTS books ( {{/* set the dialect function using Sqlite(), Postgres() or Dialect{Name: \"..\"}. */}} {{ if eq Dialect \"Postgres\" }} id SERIAL PRIMARY KEY {{ else if eq Dialect \"Sqlite\" }} id INTEGER PRIMARY KEY {{ else }} {{ fail \"invalid dialect\" }} {{ end }} , title TEXT NOT NULL {{ if eq Dialect \"Postgres\" }} , added_at TIMESTAMPTZ NOT NULL {{ else if eq Dialect \"Sqlite\" }} , added_at DATE NOT NULL {{ else }} {{ fail \"invalid dialect\" }} {{ end }} ); CREATE TABLE IF NOT EXISTS authors ( {{ if eq Dialect \"Postgres\" }} id SERIAL PRIMARY KEY, {{ else if eq Dialect \"Sqlite\" }} id INTEGER PRIMARY KEY, {{ else }} {{ fail \"invalid dialect\" }} {{ end }} name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS book_authors ( book_id INTEGER REFERENCES books(id), author_id INTEGER REFERENCES authors(id), PRIMARY KEY (book_id, author_id) ); {{ end }} {{ define \"upsert_authors\" }} INSERT INTO authors (name) VALUES {{ range $i, $a := . }} {{ if $i }}, {{ end }} ({{ $a }}) {{ end }} ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id; {{ end }} {{ define \"insert_book\" }} INSERT INTO books (title, added_at) VALUES ({{ . }}, {{ now }}) RETURNING id; {{ end }} {{ define \"link_book_authors\" }} INSERT INTO book_authors (book_id, author_id) VALUES {{ range $i, $a := .AuthorIDs }} {{ if $i }}, {{ end }} ({{ $.BookID }}, {{ $a }}) {{ end }} ON CONFLICT DO NOTHING; {{ end }} {{ define \"query_books\" }} SELECT books.id {{ ScanInt \"ID\" }} , books.title {{ ScanString \"Title\" }} {{/* ScanStringSlice scans the column as a string and splits it into a slice of strings */}} {{ if eq Dialect \"Postgres\" }} , STRING_AGG(authors.name, ',') {{ ScanStringSlice \"Authors\" \",\" }} {{ else if eq Dialect \"Sqlite\" }} , GROUP_CONCAT(authors.name) {{ ScanStringSlice \"Authors\" \",\" }} {{ else }} {{ fail \"invalid dialect\" }} {{ end }} , books.added_at {{ ScanTime \"AddedAt\" }} FROM books LEFT JOIN book_authors ON books.id = book_authors.book_id LEFT JOIN authors ON authors.id = book_authors.author_id WHERE 1=1 {{ with .Title }} AND books.title = {{ . }} {{ end }} {{ with .Author }} AND books.id IN ( SELECT ba.book_id FROM book_authors ba JOIN authors a ON a.id = ba.author_id WHERE {{ if eq Dialect \"Postgres\" }} POSITION({{ . }} IN a.name) \u003e 0 {{ else if eq Dialect \"Sqlite\" }} INSTR(a.name, {{ . }}) {{ else }} {{ fail \"invalid dialect\" }} {{ end }} ) {{ end }} {{ if not .AddedBefore.IsZero }} AND books.added_at \u003c {{ .AddedBefore }} {{ end }} GROUP BY books.id, books.title, books.added_at; {{ end }} tour/multiple_databases/repository.go package repository import ( \"context\" \"database/sql\" \"errors\" \"time\" \"github.com/Masterminds/sprig/v3\" \"github.com/go-sqlt/sqlt\" _ \"github.com/jackc/pgx/v5/stdlib\" _ \"modernc.org/sqlite\" ) type Book struct { ID int64 Title string Authors []string AddedAt time.Time } type Query struct { Title string Author string AddedBefore time.Time } type Insert struct { Title string Authors []string } type Link struct { BookID int64 AuthorIDs []int64 } func NewRepository(db *sql.DB, config sqlt.Config) (Repository, error) { config = config.With( sqlt.Funcs(sprig.TxtFuncMap()), sqlt.ParseFiles(\"multiple_databases/queries.go.tpl\"), ) schema := sqlt.Exec[any](config, sqlt.Lookup(\"schema\")) _, err := schema.Exec(context.Background(), db, nil) if err != nil { return Repository{}, err } return Repository{ DB: db, Schema: sqlt.Exec[any](config, sqlt.Lookup(\"schema\")), UpsertAuthors: sqlt.All[[]string, int64](config, sqlt.Lookup(\"upsert_authors\")), InsertBook: sqlt.One[string, int64](config, sqlt.Lookup(\"insert_book\")), LinkBookAuthors: sqlt.Exec[Link](config, sqlt.Lookup(\"link_book_authors\")), QueryBooks: sqlt.All[Query, Book](config, sqlt.NoExpirationCache(512), sqlt.Lookup(\"query_books\")), }, nil } func NewSqlite() (Repository, error) { db, err := sql.Open(\"sqlite\", \":memory:?_pragma=foreign_keys(1)\") if err != nil { return Repository{}, err } return NewRepository(db, sqlt.Sqlite()) } func NewPostgres(conn string) (Repository, error) { db, err := sql.Open(\"pgx\", conn) if err != nil { return Repository{}, err } return NewRepository(db, sqlt.Postgres()) } type Repository struct { DB *sql.DB Schema sqlt.Statement[any, sql.Result] UpsertAuthors sqlt.Statement[[]string, []int64] InsertBook sqlt.Statement[string, int64] LinkBookAuthors sqlt.Statement[Link, sql.Result] QueryBooks sqlt.Statement[Query, []Book] } func (r Repository) Create(ctx context.Context, params Insert) (id int64, err error) { tx, err := r.DB.BeginTx(ctx, nil) if err != nil { return 0, err } defer func() { if err != nil { err = errors.Join(err, tx.Rollback()) } else { err = tx.Commit() } }() authorIDs, err := r.UpsertAuthors.Exec(ctx, tx, params.Authors) if err != nil { return 0, err } id, err = r.InsertBook.Exec(ctx, tx, params.Title) if err != nil { return 0, err } _, err = r.LinkBookAuthors.Exec(ctx, tx, Link{ BookID: id, AuthorIDs: authorIDs, }) return id, err } func (r Repository) Query(ctx context.Context, params Query) ([]Book, error) { return r.QueryBooks.Exec(ctx, r.DB, params) } \u003e\u003e 8. Template Functions ","categories":"","description":"This example shows how to use sqlt with multiple databases.\n","excerpt":"This example shows how to use sqlt with multiple databases.\n","ref":"/tour/7_multiple_databases/","tags":"","title":"7. Multiple Databases"},{"body":" tour/template_functions/repository.go package repository import ( \"context\" \"math/big\" \"net/url\" \"time\" \"github.com/go-sqlt/sqlt\" \"github.com/google/uuid\" ) type aBool bool type Dest struct { // Scan can be used with types that implements the sql.Scanner interface. ID uuid.UUID // ScanBytes scans values into a byte slice. Bytes []byte // ScanTime scans values into time.Time. Time time.Time // A pointer indicates a nullable value. Date *time.Time // ScanString can be used with any kind of string values. String string // ScanInt can be used with any kind of int values. Int int32 // ScanUint can be used with any kind of uint values. Uint uint64 // ScanFloat can be used with any kind of float values. Float float32 // ScanBool can be used with any kind of bool values. Bool aBool // ScanJSON can be used to unmarshal json values into any type. Map map[string]string // ScanBinary can be used with types that implements encoding.BinaryUnmarshaler. URL url.URL // ScanText can be used with types that implements encoding.TextUnmarshaler. Big big.Int // ScanStringSlice uses a string for scanning and splits its values using a separator. StringSlice []string // ScanIntSlice uses a string for scanning and splits its values using a separator. // Conversion with strconv.ParseInt(str, 10, 64). IntSlice []int64 // ScanUintSlice uses a string for scanning and splits its values using a separator. // Conversion with strconv.ParseUint(str, 10, 64). UintSlice []uint64 // ScanFloatSlice uses a string for scanning and splits its values using a separator. // Conversion with strconv.ParseFloat(str, 64). FloatSlice []float64 // ScanBoolSlice uses a string for scanning and splits its values using a separator. // Conversion with strconv.ParseBool(str). BoolSlice []bool } var Query = sqlt.Custom[any]( func(ctx context.Context, db sqlt.DB, expr sqlt.Expression[Dest]) (string, error) { return expr.SQL, nil }, sqlt.Parse(` SELECT id\t{{ Scan \"ID\" }} , raw\t{{ ScanBytes \"Bytes\" }} , date\t{{ ScanTime \"Time\" }} , '2020-01-01'\t{{ ScanStringTime \"Date\" \"DateOnly\" \"UTC\" }} {{/* Raw preserves whitespace; sqlt collapses consecutive spaces by default. */}} , {{ Raw \"' i need space'\" }}\t{{ ScanString \"String\" }} , 100\t{{ ScanInt \"Int\" }} , 100\t{{ ScanUint \"Uint\" }} , 1.23\t{{ ScanFloat \"Float\" }} , 1\t{{ ScanBool \"Bool\" }} , '{\"some\": \"data\"}'\t{{ ScanJSON \"Map\" }} , 'one,two,three'\t{{ ScanStringSlice \"StringSlice\" \",\" }} , '-10,20,30'\t{{ ScanIntSlice \"IntSlice\" \",\" }} , '10,20,30'\t{{ ScanUintSlice \"UintSlice\" \",\" }} , '1.1,2.2,3.3'\t{{ ScanFloatSlice \"FloatSlice\" \",\" }} , '1,0,t,f'\t{{ ScanBoolSlice \"BoolSlice\" \",\" }} FROM example; `), ) // SELECT id , raw , date , '2020-01-01' , ' i need space' , 100 , 100 , 1.23 , 1 , '{\"some\": \"data\"}' , 'one,two,three' , '-10,20,30' , '10,20,30' , '1.1,2.2,3.3' , '1,0,t,f' FROM example; ","categories":"","description":"This example shows all the predefined template functions.\n","excerpt":"This example shows all the predefined template functions.\n","ref":"/tour/8_template_functions/","tags":"","title":"8. Template Functions"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/all/","tags":"","title":"All"},{"body":"NsPerOp AllocsPerOp AllocedBytesPerOp ","categories":"","description":"Results of the [Bench-Flix](https://github.com/go-sqlt/bench-flix) benchmarks.\n","excerpt":"Results of the [Bench-Flix](https://github.com/go-sqlt/bench-flix) …","ref":"/benchmarks/","tags":"","title":"Benchmarks"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/","tags":"","title":"Configs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/configure/","tags":"","title":"Configure"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/custom/","tags":"","title":"Custom"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/custom/","tags":"","title":"Custom"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/","tags":"","title":"Drivers"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/exec/","tags":"","title":"Exec"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/","tags":"","title":"Executors"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/first/","tags":"","title":"First"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/funcs/","tags":"","title":"Funcs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/jackc/pgx/","tags":"","title":"Jackc/Pgx"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/log/","tags":"","title":"Log"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/lookup/","tags":"","title":"Lookup"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/masterminds/sprig/","tags":"","title":"Masterminds/Sprig"},{"body":"","categories":"","description":"","excerpt":"","ref":"/drivers/modernc.org/sqlite/","tags":"","title":"Modernc.org/Sqlite"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/noexpirationcache/","tags":"","title":"NoExpirationCache"},{"body":"","categories":"","description":"","excerpt":"","ref":"/executors/one/","tags":"","title":"One"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/parse/","tags":"","title":"Parse"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/parsefiles/","tags":"","title":"ParseFiles"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/postgres/","tags":"","title":"Postgres"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/question/","tags":"","title":"Question"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/raw/","tags":"","title":"Raw"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scan/","tags":"","title":"Scan"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanbinary/","tags":"","title":"ScanBinary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanbool/","tags":"","title":"ScanBool"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanboolslice/","tags":"","title":"ScanBoolSlice"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanbytes/","tags":"","title":"ScanBytes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanfloat/","tags":"","title":"ScanFloat"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanfloatslice/","tags":"","title":"ScanFloatSlice"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanint/","tags":"","title":"ScanInt"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanintslice/","tags":"","title":"ScanIntSlice"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanjson/","tags":"","title":"ScanJSON"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/","tags":"","title":"Scanners"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanstring/","tags":"","title":"ScanString"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanstringslice/","tags":"","title":"ScanStringSlice"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanstringtime/","tags":"","title":"ScanStringTime"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scantext/","tags":"","title":"ScanText"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scantime/","tags":"","title":"ScanTime"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanuint/","tags":"","title":"ScanUint"},{"body":"","categories":"","description":"","excerpt":"","ref":"/scanners/scanuintslice/","tags":"","title":"ScanUintSlice"},{"body":"","categories":"","description":"","excerpt":"","ref":"/configs/sqlite/","tags":"","title":"Sqlite"}]